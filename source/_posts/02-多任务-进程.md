---
title: python进程
date: {{ date }}
tags: python
categories:
comments: true
---


#### 进程和线程的区别

```
import multiprocessing

def test()
    pass

p1 = multiprocessing.Process(target=test)

p1.start()
```

**进程：**

1. 程序运行起来就是进程  
2. 是资源分配的单位
3. 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的执行效率

**线程：**

1. 线程是进程中执行具体操作的个体 
2. 是任务调度的单位
3. 线程运行开销小，但不利于资源的管理和保护，进程正相反
4. 线程不能够独立执行，必须依存在进程中
5. 可以将进程理解为工厂中的一条流水线，而其中的线程就是这个流水线上的工人

#### 通过队列完成进程间的通信

队列：先进先出
```
from multiprocessing import Queue

# 初始化一个Queue对象
q=Queue(3)          # 最多可几收三条put信息

# 往队列中放数据
q.put('message1')   # 数据类型任意
q.put('message2')
q.put('message3')
q.put('message4')   # 会阻塞，因为队列满了

# 判断队列状态
q.full()     # False 表示队列不满
q.full()     # True 表示队列满了
q.empty()    # False 表示队列不为空
q.empty()    # True 表示队列为空

# 从队列取数据
q.get()             # 先进后出
q.get_nowait()      # 不等待取数据

```

**作用：**
通过队列解耦合，进程A下载数据，进程B处理数据，互不影响

```
import multiprocessing

def download_from_web():
    # 模拟从网上下载数据
    data == [11, 22, 33, 44]

    # 像队列中写入数据
    from temp in data:
        q.put()
        
    print("下载器已经下载完了数据并且存入到队列中。")


def analysis_data():
    '''数据处理'''
    waitting_analysis_data = list()
    # 从队列中取数据
    while True:
        data = q.get()
        waitting_analysis_data.append(data)
        
        if q.empty():
            break

    # 模拟数据处理
    print(waitting_analysis_data)


def main()
    # 1. 创建一个队列
    q = multiprocessing.Queue()
    
    # 2. 创建多个进程，将队列的应用当作实参进行传递到里面
    p1 = multiprocessing.Process(target=download_from_web, args=(q,))
    p2 = multiprocessing.Process(target=analysis_data， argd=(q,))

    p1.start()
    p2.start()
    
if __name__ == "__main__":
    main()
```

#### 进程池Pool

重复利用进程池中的进程
进程数过多时，采用进程池减少进程的数量
```
from multiprocessing import Pool

po = Pool(3)    # 定义一个进程池，最大进程数为3
po.apply_async(worker,(1,))  #要调用的目标，(传递给目标的参数元组,))
po.close()      # 关闭进程池
po.jion()       # 等待po中所有子进程完成，必须放在close()前面
```

```
from multiprocessing import Pool
import os, time, random

def worker(msg):
    t_start = time.time()
    print("%s开始执行，进程号为%d" % (msg,os.getpid()))
    # random.random() 随机生成0-1之间的浮点数
    time.sleep(random.random()*2)
    t_stop = time.time()
    print(msg,"执行完毕，好事%0.2f" % (t_stop-t_start))
    
po = Pool(3)        # 定义一个进程池，最大进程数3
for i in range(0,10):
    # Pool().apply_async(要调用的目标，(传递给目标的参数元组，))
    # 每次循环将会用空闲出来的子进程去调用目标
    po.apply_async(worker,(i,))
    
print("----start----")
po.close()          # 关闭进程池，关闭后po不再接收新的请求
po.join()           # 等待po中所有子进程执行完成，必须放在close语句之后
print("----end----")
```

#### 案例 实现copy
```
import multiprocessing
import os

def copy_file(q, file_name, old_folder_name, new_folder_name):
    '''完成文件的复制'''
    old_f = open(old_folder_name + "/" + file_name, "rb")
    content = old_f.read()
    old_f.close()
    
    new_f = open(new_folder_name + "/" + file_name, "wb")
    content = new_f.write()
    new_f.close()
    
    # 如果拷贝完了文件，那么就向队列中写入一个消息表示已经完成
    q.put(file_name)
    
def main():
    # 1. 获取用户要copy的文件夹的名字
    old_folder_name = input("请输入要copy的文件夹的名字：")
    
    # 2. 创建一个新的文件夹
    try:
        new_folder_name = old_folder_name + "[复件]"
        os.mkdir(new_folder_name)
    except:
        pass

    # 3. 获取文件夹的所有的待copy的文件名字 listdir()
    file_names = os.listdir(old_folder_name)
    # print(file_names)
    
    # 4. 创建进程池 主进程负责往进程池添加 进程池负责拷贝
    po = multiprocessing.Pool(5)
    
    # 5. 创建一个队列
    q = multiprocessing.Manager().Queue()
    
    
    # 6. 向进程池中添加copy文件的任务
    for file_name in file_names:
        po.apply_async(q, copy_file,args=(file_name, old_folder_name. new_folder_name)
    # 进程池中的进程出错时不会抛出异常。
    po.close()
    # po.join()
    all_file_num = len(file_names) # 所有文件的个数
    copy_ok_num = 0
    while True:
        file_name = q.get()
        # print("已经完成copy： %s" % file_name)
        copy_ok_num += 1
        print("\r拷贝的进度为：%.2f%%" % (copy_on_num*100 // all_file_num),end="")
        if copy_ok_num >= all_file_num:
            break
        
        print()
        
        
if __name__ == "__main__":
    main()
```