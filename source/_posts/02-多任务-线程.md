---
title: python线程
date: {{ date }}
tags: python
categories:
comments: true
---


#### 创建多线程

- demo1
```
import threading
import time

def saySorry():
    print("亲爱的，我错了，我能吃饭了吗？")
    time.sleep(1)

if __name__ == "__main__"
    for i in range(5):
        t = threading.Thread(target=saySorry)  #创建实例对象t
        t.start() #启动线程，生成子线程，运行指定参数
```

- demo2
```
import time
import threading

def sing():
    """唱歌 5秒钟"""
    for i in range(5):
        print("---正在唱：菊花茶---")
        time.sleep(1)


def dance():
    """跳舞 5秒钟"""
    for i in range(5):
        print("---正在跳舞---")
        time.sleep(1)


def main():
    t1 = threading.Thread(target=sing)  #创建实例对象t1，传参sing
    t2 = threading.Thread(target=dance) #创建实例对象t2。传参dance
    t1.start()  #生成子线程
    t2.start()  #生成子线程 


if __name__ == "__main__":
    main()
```

#### 查看线程数量
```
import time
import threading

def test1():
    for i in range(5):
        print("---test---%d" % i)   #子线程t1
        time.sleep(1)
    #如果创建Thread时执行的函数运行结束，那么意味着这个子线程结束了

def test2():
    for i in range(10):
        print("---test---%d" % i)   #子线程t2
        time.sleep(1)

def main():
    t1 = threading.Thread(target=test1) #创建实例对象t1，传参test1，不创建线程
    t2 = threading.Thread(target=test2) #创建实例对象t2，传参test2，不创建线程
    
    t1.start()          #生成子线程t1
    t2.start()          #生成子线程t2
    # 线程执行顺序不确定，可通过延时控制执行顺序 
    while True：
        print(threading.enumerate())    #获取当前程序所有线程的信息
        if len(threading,enumerous()) <= 1:
            break
        time.sleep(1)
        #主线程结束，程序就会结束，主线程结束会杀掉所有子线程。

if __name__ == "__main__":
    main() 
```

#### 通过继承Thread类完成创建线程

- demo
```
import threading
import time

class MyThread(threading.Thread):       #MyThread类继承自Thread类
    def run(self):                      #方法名必须是run()，才能实现多线程
        for i in range(3):
            time.sleep(3)
            msg = "I'm" + self.name + '@' + str(i) #name属性中保存的时当前线程的名字


i __name__ == "__main__":
    t = MyThread()          #一个实例对象只能开启一个子线程
    t.start()       #start()自动调用子类中的run()方法。
```

#### 多线程-共享全局变量
```
import threading
import time

# 定义全局变量
num = 100

def test1():
    global g_num      # 声明该变量是全局变量
    g_num += 1
    print("in test1 g_num=%d" % g_num)

def test2():
    print("in test2 g_num=%d" % g_num)      #不修改变量是可以不声明直接使用

def main():
    t1 = threading.Thread(target=test1)
    t2 = threading.Thread(target=test2)
    
    t1.start()
    time.sleep()
    
    t2.start()
    time.sleep()
    
if __name__ == "__main__":
    main()
```

> 在一个函数中，对全局变量进行修改的时候，到底是否需要使用global进行说明？

要看是否对全局变量的执行指向进行了修改，

如果修改了执行，即让全局变量指向了一个新的地方，那么必须使用global，例如test1()

如果仅仅是修改了指向的空间中的数据，此时不需要必须使用global。例如test2()

#### 多线程共享全局变量-args参数
```
def test1(temp):
    Null

# target指定这个线程去哪个函数执行代码
# args指定调用函数的时候传递什么数据过去
t1 = threading.Thread(target=test1, args=(g_num,)) # args传递元组数据类型
```

#### 多线程-共享全局变量问题
##### 互斥锁
```
# 创建互斥锁
mutex = threading.Lock()    # 同一把锁只能使用一次

# 锁定
mutex.acquire() # 如果上锁之前已被上锁，则此时阻塞在这里，直至所被解开。

# 释放
mutex.release()
```
 银行家算法 死锁预防 超时处理
 
 ### 案例-UDP聊天器
 ```
 import socket
 import threading
 
 def recv_msg(udp_socket):
    '''接受数据并显示'''
    
    # 接收数据
    while True:
        recv_data = udp_socket.recvfrom(1024)
        print(recv_data)
 
 
 def send_msg(udp_socket, dest_ip, dest_port):
    '''发送数据'''
    
    # 发送数据
    while True:
        recv_data = input()
        udp_socket.sendto(send_data.encode("utf-8"). (dest_ip, dest_port))


 def main():
    '''UDP聊天器的整体控制'''
    
    # 1. 创建套接字
    udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    
    # 2. 绑定本地信息
    udp_socket.bind("",7890)
    
    # 3. 获取对方的IP
    dest_ip = input(“请输入对方的IP：”)
    dest_port = int(input("请输入对方的port："))
    
    # 4. 创建两个线程，执行相应的功能
    t_recv = threading.Thread(target=recv_msg, args=(udp_socket,))
    t_send = threading.Thread(target=send_msg, args=(udp_socket, dest_ip, dest_port))
    
    t_recv.start()
    t_send.start()
    
        
 if __name__ == "__main__":
    main()
 ```
