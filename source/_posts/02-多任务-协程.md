---
title: python协程
date: {{ date }}
tags: python
categories:
comments: true
---

#### 协程
> 生成器 迭代器 装饰器 Python三大器

> 迭代器 -> 生成器 -> yield -> greenlet -> gevent

#### 迭代器

迭代时访问集合元素的一种方式，迭代器是一个可以记住遍历的位置的对象，迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。

1. 可迭代对象

对list、tuple、str、dict、集合等类型的数据使用for...in...的循环语法从其中依次拿到数据进行使用，我们把这样的过程称为遍历，也叫**迭代**。

但是，是否所有的数据类型都可以放到for...in...的语句中，然后让for...in...每次从中取出一条数据供我们使用，即供我们迭代吗？

```
from collections import Iterable

isinstance([11, 22, 33], Iterable)
-> True

isinstance((11, 22, 33), Iterable)
-> True

isinstance(100, Iterable)
-> False
```
##### 类的迭代、迭代器的实现
```
from collections import Iterable
from collections import Iterator

class Classmate(object):
    def __init__(self):
        self.names = list()
        self.current_num = 0
        
    def add(self, name):
        self.names.append(name)
    
    def __iter__(self):
        '''如果想要一个对象成为一个可以迭代的对象，即可以使用for，那么必须实现__iter__方法'''
        return self
    
    def __next__(self):
         '''返回调用值'''
        if self.current_num < len(self.names):
            ret = self.names[self.current_num]
            self.current_num += 1
            return ret
        else:
            raise StopIteration


classmate = Classmate()

classmate.add("张三")
classmate.add("李四")
classmate.add("王五")

# print("判断classmate是否是可以迭代的对象：",isinstance(classmate, Iterable))
# classmate_iterator = iter(classmate)
# print("判断classmate_iterator是否是迭代器：",isinstance(classmate_iterator, Iterator)

for name in classmate:
    print(name)
```
##### Fibonacci的迭代器实现
```
class Fibonacci(object):
    def __init__(self, all_num):
        self.all_num = all_num
        self.current_num = 0
        self.a = 0
        self.b = 1
    
    def __iter__(self):
        return self
        
    def __next__(self):
        if self.current_num < self.all_num:
            ret = self.a
            
            self.a, self.b = self.b, self.a+self.b
            self.current_num += 1
            
            return ret
        else:
            raise StopIteration

fibo = Fibonacci(10)

for num in fibo:
    print(num)
```

##### 并不是只有for循环能接受可迭代对象

除了for循环能接受可迭代对象，list、tuple等也能接受

__iter__()  ->  __next__() -> return 


#### 生成器

生成器是一个特殊的迭代器

##### 应用1
```
nums = [x*2 for x in range(10)]
-> [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]

nums = (x*2 for x in range(10))
-> <generator object <genexpr> at 0x7f7ec7071938>
```

列表推导式生成一个列表
生成器生成一个对象，不占用内存空间,可通过for循环调用

##### 应用2
```
def create_num(all_num):
    a, b = 0, 1
    current_num = 0
    while current_num < all_num：
        yield a     #如果一个函数中有yield语句，那么这个就不再是函数，而是一个生成器模板
        a, b = b, a+b
        current_num += 1
# 如果在调用create_num的时候，发现这个函数中由yield，那么此时不是调用函数，而是创建一个生成器对象。
obj = create_num(10)

for num in obj:
    print(num)
```

##### yield生成器获取return值
```
def create_num(all_num):
    a, b = 0, 1
    current_num = 0
    while current_num < all_num:
        yield a
        a, b = b, a+b
        current_num += 1
    return "ok...."
    
obj = create_num(20)

while True:
    try:
        ret = next(obj)
        print(ret)
    except Exception as ret:
        print(ret.value)
        break
```

##### send()传递参数
```
def create_num(all_num):
    a, b = 0, 1
    current_num = 0
    while current_num < all_num:
        ret = yield a   # 右侧语句执行暂停，传参给next()
        # send()将参数传过来，程序从暂停处开始执行，将传过来的参数赋给ret
        print("ret:", ret)
        a, b = b, a+b
        current_num += 1
    
obj = create_num(20)

ret = next(obj) 
print(ret)


ret = obj.send("hahaahha")  #等同于next()，不同的是可以传参
# send()一般不会放到第一次启动生成器，如果非要这么做，那么传递None
# 再次运行到yield a，将a的值赋给ret
print(ret)

```

### 使用yield完成多任务

```
import time

def task_1():
    while True:
        print("---1---")
        time.sleep(0.1)
        yield
        
def task_2():
    while True:
        print("---2---")
        time.sleep(0.1)
        yield

def main():
    t1 = task_1()
    t2 = task_2()
    # 先让t1运行一会，当t1中遇到yield的时候，返回此处
    # 执行t2，当它遇到yield的时候，再次切换到t1中
    # 这样t1/t2/t1/t2的交替运行，最终实现了多任务...协程
    while True:
        next(t1)
        next(t2)

if __name__ == "__main__":
    main()
```

#### 使用greenlet、gevent完成多任务

核心使用yield实现

$ pip3 install greenlet     # 安装greenlet

```
from greenlet import greenlet
import time

def test1():
    while True:
        print("---A---")
        gr2.switch()
        time.sleep(0.5)
        
def test2():
    while True:
        print("---B---")
        gr1.switch()
        time.sleep(0.5)

gr1 = greenlet(test1)
gr2 = greenlet(test2)

# 切换到gr1中运行
gr1.switch()
```

$ pip3 install gevent

- 依赖关系
协程 <- 线程<- 进程  
遇到耗时操作进行切换

```
import gevent

def f1(n):
    for i in range(n):
        print(gevent.getcurrent(), i)
        gevent.sleep(0.5)

def f2(n):
    for i in range(n):
        print(gevent.getcurrent(), i)
        gevent.sleep(0.5)

def f3(n):
    for i in range(n):
        print(gevent.getcurrent(), i)
        gevent.sleep(0.5)

g1 = gevent.spawn(f1, 5)     #  生成yield对象 f:指定函数 5:指定传参 
g2 = gevent.spawn(f2, 5)
g3 = gevent.spawn(f3, 5)
g1.join()   # 运行期间会耗时，自行切换到下一个对象
g2.join()
g3.join()
```

#### sleep补丁

- 协程使用代码示例
```
from gevent import monkey
import gevent
import random
import time

# 有耗时操作时需要
monkey.patch_all()      # 将程序中用到的耗时操作的代码，换为gevent中自己实现的模块

def coroutine_work(coroutine_name):
    for i in range(10):
        print(coroutine_name, i)
        time.sleep(random.random()

# 将多个join连接起来用一个元组实现
# 等待元组中所有协程都完成后结束当前进程
gevent.joinall([
            gevent.spawn(coroutine_work, "work1"),
            gevent.spawn(coroutine_work, "work2")
])
```

#### 案例-并发下载器

```
from gevent import monkey
import gevent
import urllib.request

monkey.patch_all()

def downloader(img_name, img_url):
    req = urllib.request.urlopen(img_orl)
    
    img_content = req.read()
    
    with open(img_name, "wb") as f:
        f.write(img_content)
        
def main():
    gevent.joinall([
                gevent.spawn(downlaoder, "1.jpg", "http://url"),
                gevent.spawn(downlaoder, "1.jpg", "http://url")
    ])

if __name__ == "__main__":
    main()
```

#### 进程、线程、协程对比

- 有一个老板想要开个工厂进行生产某件商品
- 他需要画一些财力物力制作一条生产线，这个生产线上有很多的器件以及材料这些所有的为了能够生产商品而准备的资源称之为：**进程**
- 只有生产线程时不能够进行生产的，所以老板需要找个工人来进行生产，这个工人能够利用这些材料最终一步步的将商品制作出来，这个来做事情的工人称之为：**线程**
- 这个老板为了提高生产率，想到3种方法：
    1. 在这条生产线上多找些工人，一起来做商品，这样效率是成倍增长，即**单进程 多线程**方式
    2. 老板发现这条生产线上的工人不是越多越好，因为一条生产线的资源以及材料毕竟有限，所以老板又花了写财力物力购置了一条生产线，然后再招些工人，这样效率又再一步提高了，即**多进程 多线程**方式
    3. 老板发现，现在已经有了很多条生产线，并且每条生产线上已经有很多工人了（即程序是多进程的，每个进程中又有多个线程），为了再次提高效率，老板想了个损招，规定：如果某个员工在上班时，临时没事或者再等待某些条件（比如等待另一个工人生产完某道工序之后，他才能再次工作），那么这个员工就利用这个时间去做其他的事情，那么也就是说：如果一个线程等待某些条件，可以充分利用这个时间去做其他事情，其实这就是：**协程**方式

##### 简单总结
1. 进程是资源分配的单位
2. 线程是操作系统调度的单位
3. 进程切换需要的资源最大，效率很低
4. 线程切换需要的资源一般，效率一般（不考虑GIL的情况下）
5. 协程切换任务资源很小，效率高
6. 多进程、多线程根据CPU核数不一样可能是并行的，但是协程是在一个线程中，所以是并发。